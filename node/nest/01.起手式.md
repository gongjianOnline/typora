# nest起手式

## 安装脚手架

```shell
npm install -g @nestjs/cli
nest new projectName
```

## 项目目录创建

删除 src 中多余的文件只保留 `app.module.ts` 和 `main.ts`

重置 app.module.ts 文件

```ts
import { Module } from '@nestjs/common';
@Module({
  imports: [],
  controllers: [],
  providers: [],
})
export class AppModule {}
```

## 创建相关模块

```java
nest g module user /*创建user的module*/
nest g controller User --no-spec /*创建 controller 层，忽略测试文件*/
nest g service user --no-spec /*创建 service 层，忽略测试文件*/
```

### module 、controller 和 service 三者的关系

- controller (控制器)：负责处理HTTP请求和响应，接受来自客户端的请求，并将其委派给 service 进行处理。controller 中定义了路由和处理请求的方式
- Module（模块）：应用程序的核心组织单元，负责将应用程序的不同部分组合在一起，每一个 Module 都有自己的 Controller、Service 和 其他相关组件，他们整体构成了一个模块
- Service （服务）：应用程序的业务逻辑集中地，他包含了处理业务逻辑的方法，Service 被 Controller 调用，用于处理来自客户端的请求，并返回结果，Service 可以被多个 COntroller 和其他的 Service 共享

Nest提供了结构化的方式来组织应用程序，将不同的功能模块分开管理

## 通过 get 、 post 方式请求数据

在 user.controller.ts 中创建路由

```ts
import { Controller, Get,Post } from '@nestjs/common';
import { UserService } from './user.service';

@Controller('user')
export class UserController {
  constructor(private userService:UserService){

  }
  /*客户端使用get方式访问 /user 返回结果*/
  @Get()
  getUser():any{
    return this.userService.getUser();
  }
  /*客户端使用post方式访问 /user 返回结果*/
  @Post()
  addUser():any{
    return this.userService.addUser();
  }
}
```

在 user.service.ts 中进行相关业务逻辑

```ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class UserService {
  getUser(){
    return {
      code:'101'
    }
  }

  addUser(){
    return {
      code:'101',
      msg:"添加成功"
    }
  }

}
```

---

## 常规参数接受

接受Query方式的参数

```ts
import { Controller,Get, Query } from '@nestjs/common';
import {RangService} from "./rang.service";

/*声明参数类*/
class TestQuery{
  num:number
}

@Controller('rang')
export class RangController {
  constructor(private rangService:RangService){}
  @Get()
  test(@Query() query:TestQuery){
    /*通过 @Query() 方式拿到客户端传递的参数,传递给 service 层进行业务逻辑处理*/
    return this.rangService.test(query)
  }
}
```

## 配置环境变量

安装

```shell
yarn add @nestjs/config  --save
```

在根目录创建 `.env` 文件,设置环境变量

```env
DB = Mysql
DB_HOOST = localhost
DB_PROT = 3306
DB_NAME = test
DB_USER = root
```

在 `app.module.ts` 文件.全局导入

```ts
import {ConfigModule} from "@nestjs/config";
@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal:true
    }),
    ...
  ],
  controllers: [],
  providers: [],
})
```

在其他模块中调用环境变量

```ts
import {ConfigService} from "@nestjs/config"
export class TsetCOntroller{
    @Get()
    getUSer(){
        console.log(this.configService.get("DB"));
        return ...
    }
}
```

---

## 连接Mysql数据库

```shell
yarn add @nestjs/typeorm typeorm mysql2
```

### 方式一

在 `app.module.ts` 中配置

```ts
@Module({
  imports: [
    /*数据库连接 */
    TypeOrmModule.forRoot({
      type:"mysql",
      host:"localhost",
      port:3306,
      username:"root",
      password:"example",
      database:"testdb",
      entities:[],
      synchronize:true, // 同步本地的schema与数据库
      logging:['error']
    }),
  	...
  ],
  controllers: [],
  providers: [],
})
```

使用 docker 在启动本地数据库，在根目录中创建 `docker-compose.yml`

```yml
# Use root/example as user/password credentials
version: '3.1'

services:

  db:
    image: mysql
    # NOTE: use of "mysql_native_password" is not recommended: https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html#upgrade-caching-sha2-password
    # (this is just an example, not intended to be a production configuration)
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: example
    ports:
      - 3306:3306
  adminer:
    image: adminer
    restart: always
    ports:
      - 8080:8080
```

### 方式二

配置动态的数据包库连接，创建 `.env` 文件

```env
DB_TYPE = "mysql"
DB_HOOST = "localhost"
DB_PROT = 3306
DB_USERNAME = "root"
DB_PASSWORD = "example"
DB_DATABASE = "testdb"
```

在 `app.module.ts` 配置文件

```ts
import {ConfigModule, ConfigService} from "@nestjs/config";
import { TypeOrmModule } from '@nestjs/typeorm';
@Module({
  imports: [
    /*在全局声明环境变量*/
    ConfigModule.forRoot({
      isGlobal:true
    }),
    /*数据库连接 */
    TypeOrmModule.forRootAsync({
      imports:[ConfigModule],
      inject:[ConfigService],
      useFactory:(configService:ConfigService)=>({
        type:configService.get("DB_TYPE") as 'mysql',
        host:configService.get("DB_HOOST"),
        port:configService.get("DB_PORT"),
        username:configService.get("DB_USERNAME"),
        password:configService.get("DB_PASSWORD") as string,
        database:configService.get("DB_DATABASE") as string,
        entities:[],
        synchronize:true, // 同步本地的schema与数据库
        logging:['error']
      })
    }),
    UserModule, 
    RangModule],
  controllers: [],
  providers: [],
})
```

---

## 使用 typeorm 创建表和字段

创建 `user.entity.ts` 文件

```ts
import {Entity,PrimaryGeneratedColumn, Column} from "typeorm"

@Entity()
export class User {
  /*表示自增主键*/  
  @PrimaryGeneratedColumn() 
  id:number;
  /*非主键列*/
  @Column()
  username:string;
  @Column()
  password:string;
}
```

在 `app.module.ts` 中添加

```ts
@Module({
    imports:[
        TypeOrmModule.forRootAsync({
       		...
          useFactory:(configService:ConfigService)=>({
       		...
            entities:[User], /*添加要创建的表*/
     		...
          })
    	}),
    ]
})
```

### 创建一对一关系

```ts
@OneToOne(()=>User)
@JoinColumn()
user:User
```

### 创建一对多关系

```ts
@OneToMany(()=>Logs,(logs)=>logs.user)
logs:Logs[]

/*****************************************/
@ManyToOne(()=>User,(user)=>user.logs)
@JoinColumn()
user:User;
```

### 创建多对多关系

```ts
@ManyToMany(()=>Logs,(logs)=>logs.user)
logs:Logs[]
/***************************************/
@ManyToMany(()=>User,(user)=>user.logs)
@JoinColumn()
user:User;
```

---

## Log日志操作

### 设置日志级别

在 `main.ts` 中配置

```ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule,{
    /**关闭nest日志 */
    logger:false
	/**选择日志级别*/
    logger:["log","error","warn"]
  });
  await app.listen(3000);
}
bootstrap();
```

### 在控制器中打印log

```ts
@Controller()
export class UserController{
    private logger = new Logger(UserController.name)
    constructor(){}
    
    @Get()
    getUser():any{
        this.logger.log("请求成功");
    }
}
```

### 使用第三方日志管理 pino

安装

```shell
yarn add pino-http pino-pretty  pino-roll
```

在全局配置日志系统 `app.module.ts`

```ts
@Module({
  imports: [
  	...
    LoggerModule.forRoot({
      pinoHttp:{
        transport:{
          targets:[
            {
              level:"info",
              target:"pino-pretty",
              options:{
                colorize:true,
              },
            },
            {
              level:"info",
              target:"pino-roll",
              options:{
                file:join("logs","log.txt"),
                frequency:"daily",
                size:"10m",
                mkdir:true
              }
            }
          ]
        }
      }
    })
   	...
  ],
  controllers: [],
  providers: [],
})
export class AppModule {}
```

### 使用第三方日志管理 winston

安装

```shell
yarn add --save nest-winston winston winston-daily-rotate-file
```

配置`main.ts`

```ts
async function bootstrap() {
  /*配置winston相关参数*/
  const instance = createLogger({
    transports:[
      new winston.transports.Console({
        format:winston.format.combine(
          winston.format.timestamp(),
          winston.format.simple()
        )
      }),
      new winston.transports.DailyRotateFile({
        dirname:"logs",
        level:"warn",
        filename:"application-%DATE%.log",
        datePattern:"YYYY-MM-DD-HH",
        zippedArchive:true,
        maxSize:"20m",
        maxFiles:"14d",
        format:winston.format.combine(
          winston.format.timestamp(),
          winston.format.simple()
        )
      })
    ]
  })

  const app = await NestFactory.create(
    AppModule,
    {
      logger:WinstonModule.createLogger({instance}) /*全局使用*/
    }
  );
  await app.listen(3000);
}
```

