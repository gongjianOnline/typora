# ref ,reactive 响应式引用的用法和原理

## ref 

- ref 处理基础类型的数据
- 原理， 通过proxy 对数据进行封装，当数据变化时，出发模板等内容的更新

```javascript
const app = Vue.createApp({
    template: `
      <div>{{name}}</div>
    `,
    setup(props,content){
      const {ref} = Vue;
      // proxy , "dell" 变成 proxy({valkue:'dell'})这样的一个响应式引用
      let name = ref('dell');
      setTimeout(()=>{
        name.value = 'lee'
      },5000)
      return{name}
    }
})
const vm = app.mount('#root');

```

---

## reactive

- 处理非基础类型的数据

```javascript
const app = Vue.createApp({
    template:`
      <div>{{nameObj.name}}</div>
    `,
    setup(props,contenxt){
      const {reactive} = Vue;
      // proxy,{name:'dell'}编程proxy({name:'dell'})这样的响应式引用
      const nameObj = reactive({name:"dell"});
      setTimeout(()=>{
        nameObj.name = "hello world"
      },5000)
      return {nameObj}
    }
})
const vm = app.mount('#root');
```

---

## readonly

- 将对象变成只读属性

```javascript
const app = Vue.crateApp({
    template:`
		<div>{{nameObj.name}}</div>
	`,
    setup(props,contenxt){
        const {readonly} = Vue;
        const nameObj = readonly({name:"dell"})
        setTimeout(()=>{
            nameObj.name = "hello world"
        },5000)
       	return {nameObj}
    }
})
const vm = app.mount("#root")
```

---

## toRefs

- 用于对象的析构赋值

```javascript
const app = Vue.crateApp({
    template:`
		<div>{{name}}</div>
	`,
    setup(props,contenxt){
        const {reactive,toRefs} = Vue;
        const nameObj = reactive({name:"dell"})
        setTimeout(()=>{
            nameObj.name = "hello world"
        },5000)
        // toRefs proxy({name:'dell'}),{name:proxy({values:'dell'})}
        const {name} = toRefs(nameObj)
       	return {name}
    }
})
const vm = app.mount("#root")
```



