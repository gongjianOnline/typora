# JS运行原理和垃圾回收机制

## JS运行原理

### 名词介绍

- 堆：heap
- 栈：stack
  - 执行环境栈
  - 作用：
    - 供代码执行
- 上下文：EC
  - EC(G)：全局执行上下文
    - 目的：区别代码执行环境
    - 全局代码都在全局上文中执行
- 全局对象：GO
  - 存储浏览器内置API
  - 浏览器（window）；node中（global）
- 变量对象 VO、AO
  - VO(G) 变量对象
    - 存储当前上下文声明的变量

---

### 赋值的执行过程

- 创建一个值
  - 原始值：存在占内存
  - 对象：存在堆内存
- 声明变量，把声明的变量存储在当前上下文的VO/AO
- 让变量和创建的值关联到一起

**在JS中所有的赋值都是指针引用**

---

### 对象的执行过程

- 开辟一个堆内存，产生一个地址（16进制）
- 把对象中的键值对一次存储到空间中
- 把空间地址存在栈中，供变量使用

---

### 函数的底层执行机制

#### 创建函数

- 开辟一个堆内存，有一个16进制的地址
- 存储内容
  - 函数体重的代码当做字符串先存储
  - 当做普通对象也会存一个键值对
- 创建函数的时候声明了作用域（scope）
- 把堆内存的地址放在栈中，供函数名去调用

#### 执行函数

- 形成一个私有的执行上下文（EC），然后进栈执行
- 初始化作用域
  - 初始化 this
  - 初始化 args 集合
  - 形参赋值--形成私有变量
  - 变量提升
  - 代码执行
- 根据情况，私有上下文是释放

**函数的作用域一定是创建他的上下文，和调用的位置无关**

---

## 闭包机制

1. 当函数执行完，一般情况下，当前形成的上下文都会被出栈释放；上下文被释放之前存储的私有变量也会被释放
2. 如果当前上下文中的某些东西（堆内存），被当前的上下文以外的事物所占用，则当前上下文不能出栈释放；之前的变量会被存储起来——闭包

总结

​	闭包机制，函数执行产生的私有上下文，一方面可以保护里面的私有变量不被污染，另一方面如果不被释放，私有的变量及相关信息也会都会被保存起来，我们把这种保护的机制，称之为闭包（**面试的标准答案**）

---

## 浏览器的垃圾回收机制

堆内存释放问题：如果当前的堆被占用了【地址引用】则不能释放，如果不被引用，浏览器会在空闲的时候释放。

GC：浏览器的垃圾回收机制

一、引用计数【被占用1次累加1，取消运用减去1，当前到0的时候，会释放掉】

二、引用检测 标记清除怕【被占用后做一个标记，当移除引用，取消标记，在浏览器空闲的时候，会把所有未被标记的内容回收】