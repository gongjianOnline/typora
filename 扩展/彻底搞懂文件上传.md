# 彻底搞懂文件上传

传统原生表单上传样式已经不满足现在前端发展的需求，现在市场通常采用各种第三方UI组件库满足日常所需。但在开发中包括我在内的不少开发者知其然却不知其所以然，这篇文章让我们彻底搞懂文件上传的各个场景

## 单一文件上传

### 实现思路

- 实现上传功能仍然需要借助 input 的 file 属性，并隐藏隐藏元素
- 使用 js 手动触发 input 事件
- 用 html 元素优化代替原生的 input 的样式

### 优化结果

![](https://raw.githubusercontent.com/gongjianOnline/ImgHosting/main/img/1650950932(1).png)

### 实现代码

#### html

```html
  <div class="container">
    <div class="buttonContainer">
      <input type="file" id="inputInput" style="display:none">
      <div class="button-select button">选择文件</div>
      <div class="button-submit button">上传文件</div>
    </div>
    <div>文件仅支持png格式的文件</div>
    <div>
      <ul id="list"></ul>
    </div>
  </div>
```

HTML 部分的样式内容忽略，但其中的技术点在于 **隐藏了 input 元素** ，用 div 模拟了选择文件和上传文件按钮

#### javaScript

```javascript
let inputInput = document.querySelector("#inputInput")
let select = document.querySelector(".button-select")
let submit = document.querySelector(".button-submit")
let list = document.querySelector("#list")
let filesData;

// 获取本地文件
inputInput.onchange=()=>{
  let files = inputInput.files[0]
  console.log(files)
  if(files.type !== "image/png"){
    alert("文件只支持png格式")
    return
  } 
  if(files.size>2*1024*1024){
    alert("文件最大支持2MB")
    return
  }
  filesData = files
  list.innerHTML = `
    <li>${files.name} <span class="del">移除</span></li>
  `
}
// 时间委托
list.onclick = (event)=>{
  if(event.target.innerHTML === "移除"){
    list.innerHTML = "";
    filesData = null
  }
}
// 触发上传的click事件
select.onclick = ()=>{
  inputInput.click()
}
// 提交
submit.onclick = ()=>{
  if(filesData){
    let formData = new FormData();
    formData.append("files",filesData)
    fetch("www.baidu.com",{
      method:"POST",
      body:formData
    }).then((response)=>{
      console.log(response)
    })
  }
}
```

上面的 javascript 代码， 获取“选择文件” select ，在 select 点击的时候触发 input 的点击事件，弹出文件选择器； 绑定 input 的 change 事件 监听选中的文件对象， 通过 files 属性获取对象全部信息并作相应的业务判断，比如 文件类型、文件大小、文件上传列表等。通过点击 submit 元素手动创建 formData 实例 将文件元素添加进去，传给后端

---

## 单一文件上传BASE64

单一文件上传将文件转为 base64编码 ， 主要借助 FileReader 实例对象，该对象不仅可以转化为 base64，还支持 readAsArrayBuffer 的转换。

### 实现结果

![](https://raw.githubusercontent.com/gongjianOnline/ImgHosting/main/img/1650952479(1).png)

以上代码的实现形式，点击 选择文件 按钮，选择文件后自动上传。

### 实现方式

#### html

```html
  <div class="container">
    <div class="buttonContainer">
      <input type="file" id="inputInput">
      <div class="button-select button">选择文件</div>
    </div>
    <div>文件仅支持png格式的文件</div>
  </div>
```

#### javascript

```javascript
let inputInput = document.querySelector("#inputInput")
let select = document.querySelector(".button-select")

let fileReader =(files)=>{ 
  return new Promise((resolve,reject)=>{
    let fileReader = new FileReader();
    fileReader.readAsDataURL(files)
    fileReader.onload=(event)=>{
      resolve(event.target.result)
    }
  })
}
// 获取本地文件
inputInput.onchange=async ()=>{
  let files = inputInput.files[0]
  if(files.size>2*1024*1024){
    alert("文件最大支持2MB")
    return
  }
  let base64 = await fileReader(files)
  fetch("http://www.baidu.com",{
    method:"POST",
    headers:{
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body:JSON.stringify({
      files:base64,
      filesName:files.name
    })
  })
}
// 触发上传的click事件
select.onclick = ()=>{
  inputInput.click()
}
```

实现自动上传的逻辑，主要是监听 input file 的 change 事件，在 change 事件中直接处理图片为 base64 编码，然后请求后台接口。 

值得注意的是 FileReader 的实例为异步方法，所以上面代码对 FileReacer 做了 Promise 的封装，至于不了解 Promise 的小伙伴请自行百度知识盲区。

---

## 文件上传缩略图

借助 base64 编码 实现文件缩略图效果

### 实现结果

![](https://raw.githubusercontent.com/gongjianOnline/ImgHosting/main/img/1650952842(1).png)

### 实现逻辑

将文件 编码为base64，复制给 img 元素

#### html

```html
  <div class="container">
    <div class="buttonContainer">
      <input type="file" id="inputInput">
      <div class="button-select button">选择文件</div>
      <div class="button-submit button">上传文件</div>
    </div>
    <div>
      <img src="" alt="" id="img">
    </div>
  </div>
```

#### javascript

```javascript
let inputInput = document.querySelector("#inputInput")
let select = document.querySelector(".button-select")
let submit = document.querySelector(".button-submit")
let img = document.querySelector("#img")
let filesData;

// 将文件转成base64
const toBase64 = (files)=>{
  return new Promise((resolve,reject)=>{
    let fileReader = new FileReader();
    fileReader.readAsDataURL(files)
    fileReader.onload=(event)=>{
      resolve(event.target.result)
    }
  })
}

// 获取本地文件
inputInput.onchange=async ()=>{
  let files = inputInput.files[0]
  console.log(files)
  if(files.size>2*1024*1024){
    alert("文件最大支持2MB")
    return
  }
  filesData = files;
  let base64 = await toBase64(files);
  console.log("base64",base64)
  img.src = base64
}
// 触发上传的click事件
select.onclick = ()=>{
  inputInput.click()
}
// 提交
submit.onclick = ()=>{
  if(filesData){
    let formData = new FormData();
    formData.append("files",filesData)
    fetch("www.baidu.com",{
      method:"POST",
      body:formData
    }).then((response)=>{
      console.log(response)
    })
  }
}
```

---

## 文件上传进度管控

使用 axios 或者 原生 XHR 发起接口请求，其中这两个实例中提供了 onUploadProgress 属性， onUploadProgress 为一个回调函数，监听上传状态 其中  loaded 为当前上传的数量，total 为文件总量。

值得注意的是新的 fetch 请求方式，无法监听文件上传和下载进度状态

### 实现结果

![](https://raw.githubusercontent.com/gongjianOnline/ImgHosting/main/img/1650953031(1).png)

### 实现方式

#### html

```html
  <div class="container">
    <div class="buttonContainer">
      <input type="file" id="inputInput">
      <div class="button-select button">选择文件</div>
      <div class="button-submit button">上传文件</div>
    </div>
    <div>文件仅支持png格式的文件</div>
    <div class="progress">
      <div class="progressBar" style="width: 10%;"></div>
    </div>
  </div>
```

#### javascript

```javascript
let inputInput = document.querySelector("#inputInput")
let select = document.querySelector(".button-select")
let submit = document.querySelector(".button-submit")
let progressBar = document.querySelector(".progressBar")
let filesData;


// 获取本地文件
inputInput.onchange=()=>{
  let files = inputInput.files[0]
  console.log(files)
  if(files.type !== "text/plain"){
    alert("文件只支持text格式")
    return
  } 
  if(files.size>2*1024*1024){
    alert("文件最大支持2MB")
    return
  }
  filesData = files
}
// 触发上传的click事件
select.onclick = ()=>{
  inputInput.click()
}
// 提交
submit.onclick = ()=>{
  if(filesData){
    let formData = new FormData();
    formData.append("files",filesData)
    axios({
      method:"POST",
      url:"https://jsonplaceholder.typicode.com/posts/",
      data:formData,
      onUploadProgress:(ev)=>{
        let {loaded,total} = ev;
        progressBar.style.width = `${loaded/total*100}%`
      }
    }).then((response)=>{
      console.log(response)
    })
  }
}
```

---

## 多文件上传及进度管控

同单文件实现思路一样，多文件上传针对每个文件进行进度管控的方案在于，每一个文件都会单独请求一次接口。

优点：可以对每一个文件进行管控，并且会降低文件上传到容量

缺点：会重复多次的调用一个接口，对接口和服务器造成的压力较大

针对于合并多文件请求的方式之前在 element 模块中《文件上传》中总结过 实现的方法， 感兴趣的小伙伴可以移步去另一篇文章

### 实现结果：



![](https://raw.githubusercontent.com/gongjianOnline/ImgHosting/main/img/1650959010(1).png)

### 实现方式

#### html

```html
  <div class="container">
    <div class="buttonContainer">
      <input type="file" id="inputInput" multiple>
      <div class="button-select button">选择文件</div>
      <div class="button-submit button">上传文件</div>
    </div>
    <div>文件仅支持png格式的文件</div>
    <div>
      <ul id="list">
        
      </ul>
    </div>
  </div>
```

#### javascript

```javascript
let inputInput = document.querySelector("#inputInput")
let select = document.querySelector(".button-select")
let submit = document.querySelector(".button-submit")
let list = document.querySelector("#list")
let filesData;

// 获取本地文件
inputInput.onchange=()=>{
  filesData =Array.from(inputInput.files) 
  console.log("多文件上传",filesData)
  filesData.map((item)=>{
    list.innerHTML+= `
      <li>
        ${item.name}
        <div class="progress">
          <div class="progressBar" data-name="${item.name}" style="width:10%"></div>
        </div>
      </li>
    `
  })
}
// 触发上传的click事件
select.onclick = ()=>{
  inputInput.click()
}
// 提交
submit.onclick = ()=>{
  console.log(filesData)
  if(filesData.length){
    filesData.map((item)=>{
      let formData = new FormData();
      formData.append("files",item)
      axios({
        method:"POST",
        url:"https://jsonplaceholder.typicode.com/posts/",
        data:formData,
        onUploadProgress:(ev)=>{
          let el = document.querySelector(`div[data-name="${item.name}"]`)
          let {loaded,total} = ev;
          el.style.width = `${loaded/total*100}%`
        }
      }).then((response)=>{
        console.log(response)
      })
    })
  }
}
```

上面 JS 的实现逻辑为 每一个 li 元素绑定唯一的 自定义属性目前以为文件名称作为唯一值，在调用接口的中监听 onUploadProgress 利用当前的 file 对象的 name 属性，找到相对的 DOM 节点，计算进度并赋值。

---

## 拖拽上传

拖拽上传的实现方式 主要于借助了 H5 的API  dragover \ drop 方法，用来监听在此区域内的鼠标移动和放下事件。

### 实现结果

![](https://raw.githubusercontent.com/gongjianOnline/ImgHosting/main/img/1650962184(1).png)

### 实现方式

#### html

```html
  <div class="container" id="upWrapper">
    <div class="content">
      <img src="./img/上传.png" alt="">\
    </div>
  </div>
```

#### javascript

```javascript
let upWrapper = document.querySelector("#upWrapper")
  // 进入事件
  upWrapper.addEventListener("dragover",(event)=>{
    event.preventDefault();
  })
  // 放置事件
  upWrapper.addEventListener("drop",(event)=>{
    event.preventDefault();
    submit(event.dataTransfer.files)
  })
  // 提交事件
  const submit = (filesData)=>{
    let formData = new FormData();
    formData.append("files",filesData)
    axios({
      method:"POST",
      url:"https://jsonplaceholder.typicode.com/posts/",
      data:formData,
    }).then((response)=>{
      console.log(response)
    })
  }
```

上面 js 的主要逻辑为， 在 drop 事件中获取 文件的属性 event.dataTransfer.files ，然后将文件属性传给服务端。

---

## 

